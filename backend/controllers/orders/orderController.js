const Order = require('../../models/orders/order');
const Cart = require('../../models/cart/cart');
const Product = require('../../models/products/product');
const User = require('../../models/auth/auth');
const { sendOrderConfirmationEmail, sendOrderStatusUpdateEmail, sendAdminOrderNotification } = require('../../utils/emailSender');

/**
 * Place a new order
 */
exports.placeOrder = async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Find user's cart
    const cart = await Cart.findOne({ userId });
    
    if (!cart || cart.items.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot place order with empty cart'
      });
    }
    
    // Verify stock availability for all items
    for (const item of cart.items) {
      const product = await Product.findById(item.productId);
      
      if (!product) {
        return res.status(404).json({
          success: false,
          message: `Product with ID ${item.productId} no longer exists`
        });
      }
      
      if (product.stock < item.quantity) {
        return res.status(400).json({
          success: false,
          message: `Not enough stock for ${product.name}. Only ${product.stock} available.`
        });
      }
    }
    
    // Get order details from request body
    const { shippingAddress, paymentMethod, totalAmount, shippingFee, couponCode, couponDiscount } = req.body;
    
    // Create new order
    const order = new Order({
      userId,
      items: cart.items,
      totalPrice: totalAmount || cart.totalPrice,
      shippingFee: shippingFee || 0,
      shippingAddress,
      paymentMethod: paymentMethod || 'cod',
      couponCode: couponCode || null,
      couponDiscount: couponDiscount || 0,
      paymentStatus: 'pending',
      orderStatus: 'pending'
      // orderId will be auto-generated by the model
    });
    
    // Save the order
    await order.save();
    
    // Update product stock
    for (const item of cart.items) {
      await Product.findByIdAndUpdate(
        item.productId,
        { $inc: { stock: -item.quantity } }
      );
    }
    
    // Clear the cart
    cart.items = [];
    cart.totalPrice = 0;
    await cart.save();
    
    // Send order confirmation email
    const user = req.user;
    await sendOrderConfirmationEmail(user.email, order);
    
    res.status(201).json({
      success: true,
      message: 'Order placed successfully',
      data: order
    });
  } catch (error) {
    console.error('Error placing order:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to place order',
      error: error.message
    });
  }
};

/**
 * Get all orders for current user
 */
exports.getMyOrders = async (req, res) => {
  try {
    const userId = req.user.id;
    const { page = 1, limit = 10, status } = req.query;
    
    // Build query
    const query = { userId };
    
    // Add status filter if provided
    if (status) {
      query.orderStatus = status;
    }
    
    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Find orders
    const orders = await Order.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit))
      .populate({
        path: 'items.productId',
        select: 'name images'
      });
    
    // Count total orders for pagination
    const totalOrders = await Order.countDocuments(query);
    
    res.status(200).json({
      success: true,
      data: {
        orders,
        totalPages: Math.ceil(totalOrders / parseInt(limit)),
        currentPage: parseInt(page),
        totalOrders
      }
    });
  } catch (error) {
    console.error('Error fetching orders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch orders',
      error: error.message
    });
  }
};

/**
 * Get single order details
 */
exports.getOrderById = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    
    // Find order
    const order = await Order.findById(id).populate({
      path: 'items.productId',
      select: 'name description images'
    });
    
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }
    
    // Check if order belongs to user or user is admin
    if (order.userId.toString() !== userId && req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to access this order'
      });
    }
    
    res.status(200).json({
      success: true,
      data: order
    });
  } catch (error) {
    console.error('Error fetching order:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch order details',
      error: error.message
    });
  }
};

/**
 * Admin: Get all orders with filters
 */
exports.getAllOrders = async (req, res) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to access all orders'
      });
    }
    
    const { 
      page = 1, 
      limit = 10, 
      status, 
      paymentStatus,
      search,
      sortBy = 'createdAt',
      sortOrder = 'desc'
    } = req.query;
    
    // Build query
    const query = {};
    
    // Add status filter if provided
    if (status) {
      query.orderStatus = status;
    }
    
    // Add payment status filter if provided
    if (paymentStatus) {
      query.paymentStatus = paymentStatus;
    }
    
    // Add search filter if provided
    if (search) {
      query.$or = [
        { '_id': { $regex: search, $options: 'i' } }
      ];
    }
    
    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Determine sort order
    const sort = {};
    sort[sortBy] = sortOrder === 'asc' ? 1 : -1;
    
    // Find orders
    const orders = await Order.find(query)
      .sort(sort)
      .skip(skip)
      .limit(parseInt(limit))
      .populate({
        path: 'userId',
        select: 'firstName lastName email'
      })
      .populate({
        path: 'items.productId',
        select: 'name images'
      });
    
    // Count total orders for pagination
    const totalOrders = await Order.countDocuments(query);
    
    res.status(200).json({
      success: true,
      data: {
        orders,
        totalPages: Math.ceil(totalOrders / parseInt(limit)),
        currentPage: parseInt(page),
        totalOrders
      }
    });
  } catch (error) {
    console.error('Error fetching all orders:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch orders',
      error: error.message
    });
  }
};

/**
 * Admin: Update order status
 */
exports.updateOrderStatus = async (req, res) => {
  try {
    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to update order status'
      });
    }
    
    const { id } = req.params;
    const { orderStatus, paymentStatus } = req.body;
    
    // Find order
    const order = await Order.findById(id);
    
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }
    
    // Update order status if provided
    if (orderStatus) {
      // Check if status is valid
      if (!['pending', 'confirmed', 'shipped', 'delivered', 'cancelled'].includes(orderStatus)) {
        return res.status(400).json({
          success: false,
          message: 'Invalid order status'
        });
      }
      
      // Handle stock adjustment for cancelled orders
      if (orderStatus === 'cancelled' && order.orderStatus !== 'cancelled') {
        // Return items to stock
        for (const item of order.items) {
          await Product.findByIdAndUpdate(
            item.productId,
            { $inc: { stock: item.quantity } }
          );
        }
      }
      
      order.orderStatus = orderStatus;
    }
    
    // Update payment status if provided
    if (paymentStatus) {
      // Check if status is valid
      if (!['pending', 'paid', 'failed'].includes(paymentStatus)) {
        return res.status(400).json({
          success: false,
          message: 'Invalid payment status'
        });
      }
      
      order.paymentStatus = paymentStatus;
    }
    
    // Save updated order
    await order.save();
    
    // Send status update email to customer
    const user = await require('../../models/auth/auth').findById(order.userId);
    if (user) {
      await sendOrderStatusUpdateEmail(user.email, order);
    }
    
    res.status(200).json({
      success: true,
      message: 'Order status updated successfully',
      data: order
    });
  } catch (error) {
    console.error('Error updating order status:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update order status',
      error: error.message
    });
  }
};